Bivariate Kate-Zaverucha-Goldberg (KZG) Constant-Sized Polynomial Commitments
---

The KZG commitment scheme, introduced in 2010 by Kate, Zaverucha, and Goldberg, is among the most prevalent polynomial commitment schemes.

This article presents a variant of the KZG commitment, the bivariate KZG commitment, which allows us to commit to polynomials with two variables. Subsequently, we demonstrate that this commitment scheme is particularly well-suited for distributed computation.

# Motivation


The primary goal of bivariate KZG (Bi-KZG) is to elevate the capabilities of distributed computing. Within this domain, Bi-KZG finds application in two principal Zero-Knowledge (ZK) approaches:

- **Plonk-based**: See [Pianist](https://eprint.iacr.org/2023/1271) for further reference.
- **GKR-based**: We developed DExpander, which is based on GKR and Bi-KZG. The GKR employed here is a modified version derived from the original [Libra](https://eprint.iacr.org/2019/317) paper.

Our focus is on the GKR-based approach. In the original Libra paper, the GKR + KZG solution requires $O(\log{n})$ pairings for the verifier, where $n$ is the input layer size. This requirement stems from the fact that GKR is based on Multi-Linear Extension (MLE), where a polynomial has $O(\log{n})$ variables. In Libra, we used a $O(\log{n})$ variate KZG commitment to commit the MLE, which incurs $O(\log{n})$ pairings for the verifier. Since pairings are extremely expensive for on-chain pre-compilation, minimizing on-chain costs is crucial.

In our solution, we modified the MLE in the input layer to a Bivariate Extension. The Bivariate Extension of an array $V = \[v _0, v _1, \ldots, v _{n-1}\]$ is denoted by the polynomial $ \tilde{V} (x, y) $, and the evaluation of the polynomial is defined as follows:

$$ \tilde{V}(x, y) := v_{x \cdot \frac{n}{M} + y}, \quad 0 \le x \le M, \quad 0 \le y \le \frac{n}{M} $$

where $M$ is the number of machines in the distributed scenario.

Each machine exclusively stores its designated range of values from the array $V$. A detailed exposition of the algorithmic intricacies will be presented in an upcoming blog post dedicated to distributed GKR, scheduled for release next week.






# The commitment scheme
## Pairing
Both univariate and bivariate KZG commitment schemes work over pairing friendly curves. See [here](https://en.wikipedia.org/wiki/Pairing-based_cryptography) for its definitions, and [bn254](https://hackmd.io/@jpw/bn254) and [bls12-381](https://hackmd.io/@benjaminion/bls12-381) are two popular instantiations of such curves. Recall that such set of curves consist of three cyclic groups, namely $\mathbb{G}_1$, $\mathbb{G}_2$ and $\mathbb{G}_t$, of a same group order $p$, equipped with a bilinear pairing mapping:

$$
\forall x \in \mathbb{F}_{p}, y \in \mathbb{F} _{p}, g_1 \in \mathbb{G}_1, g_2\in \mathbb{G}_2,\quad\quad e(g_1^x, g_2^y) = e(g_1, g_2)^{xy} \in \mathbb{G}_t
$$

## Trust Setup

In the univariate KZG commitment scheme, if we aim to commit to polynomials of degree $\le \ell$, we need to set up the so-called $\ell-$ Strong Diffie-Hellman ($\ell$-SDH) public parameters: $(g_1, g_1^{\tau}, g_1^{\tau^2}, ..., g_1^{\tau^\ell}) = (g_1^{\tau^i})_{i\in [0,\ell]}$ over a cyclic group $\mathbb{G}_1$ generated by $g_1$. Here, $\tau$ is the trapdoor, often referred to as "the toxic waste" within our community, and should remain unknown to all. Public ceremonies are conducted to establish consensus on these public parameters. For instance, refer to [the ceremony](https://ceremony.ethereum.org/) held by the Ethereum Foundation for Proto-Danksharding, also known as [EIP-4844](https://www.eip4844.com/).

Similarly, in the bivariate KZG commitment scheme, if we aim to commit to polynomials of degrees $\le N$ and $\le M$ respectively, we need to set up a public parameter for the $N \times M$-SDH over a cyclic group $\mathbb{G}_1$ generated by $g_1$:


$$
(g_1^{\tau_0^i\tau_1^j})_{i\in [0,N], j\in [0, M]} = \\
(g_1, g_1^{\tau_0}, g_1^{\tau_0^2}, ..., g_1^{\tau_0^N}, g_1^{\tau_1}, g_1^{\tau_0\tau_1}, g_1^{\tau_0^2\tau_1}, ..., g_1^{\tau_0^N\tau_1}, ..., g_1^{\tau_0^N\tau_1^M})
$$

Here, $\tau_0$ and $\tau_1$ serve as the trapdoors. Furthermore, as we need to commit to a bivariate polynomial, we also establish two public parameters in $\mathbb{G}_2$ to act as verification keys:

$$
g_2^{\tau_0}, g_2^{\tau_1}
$$

Observe that the public parameters exhibit additive homomorphism. This property allows us to employ a multi-party computation protocol, also known as a ceremony, to reach consensus on the public parameters. In this process, no single entity gains knowledge of the secrets $\tau_0$ and $\tau_1$.

## Commitments

Given a bivariate polynomial:

$$f(x, y) = \sum_{i=0}^{N−1}\sum_{j=0}^{M−1}a_{i,j}x^iy^j$$

its commitment is defined as:

$$
c = \prod_{i\in [0,N], j\in [0, M]}(g_1^{\tau_0^i\tau_1^j})^{a_{i,j}}
$$

In this context, we utilize the coefficient form of the polynomial to calculate the commitment. However, in practical scenarios, the polynomial might be represented in its Lagrange form, that is, a list of points interpolated using Lagrange's method. To accommodate such polynomials, we make minor modifications to the scheme.

### Lagrange Polynomial

#### Univariate Lagrange Polynomial
Remember that a Lagrange representation of a univariate polynomial is expressed as a list of points: $(\omega^0, a_0), (\omega^0, a_0), ..., (\omega^{N-1}, a_0)$, where $\omega$ is the $N$-th root of unity and can be omitted for simplicity. Let the $i$-th Lagrange polynomial be denoted by $L_i(x)$. This polynomial satisfies the following properties:

$$
\displaylines{
L_i(\omega^i) = 1 \\
\forall j\neq i, L_j(\omega^j) = 0
}
$$

Hence, we can formulate $L_i(x)$ and $f(x)$ as follows:

$$
\displaylines{
L_i(x) = \frac{\prod_{j\neq i}(\omega^j-x)}{\prod_{j\neq i}(\omega^j-\omega^i)}\\
f(x) = \sum\limits_{i=0}^{N-1}a_iL_i = \sum\limits_{i=0}^{N-1}a_i\frac{\prod_{j\neq i}(\omega^j-x)}{\prod_{j\neq i}(\omega^j-\omega^i)}
}
$$

#### Bivariate Lagrange Polynomial
The bivariate case is slightly more complex. Given a list of points:

$$
\begin{matrix}
((\omega_0^0, \omega_1^0), a_{0,0}),& ((\omega_0^1, \omega_1^0), a_{1,0}), &((\omega_0^2, \omega_1^0), a_{2,0}),&  ..., &((\omega_0^{N-1}, \omega_1^0), a_{N-1,0}), \\
((\omega_0^0, \omega_1^1), a_{0,1}),& ((\omega_0^1, \omega_1^1), a_{1,1}), &((\omega_0^2, \omega_1^1), a_{2,1}),&  ..., &((\omega_0^{N-1}, \omega_1^1), a_{N-1,1}), \\
\vdots & \vdots & \vdots & \ddots & \vdots\\
((\omega_0^0, \omega_1^{M-1}), a_{0,M-1}),& ((\omega_0^1, \omega_1^{M-1}), a_{1,M-1}),& ((\omega_0^2, \omega_1^{M-1}), a_{2,M-1}),&  ...,& ((\omega_0^{N-1}, \omega_1^{M-1}), a_{N-1,M-1})
\end{matrix}
$$

<!-- 
$$
\displaylines{
((\omega_0^0, \omega_1^0), a_{0,0}), ((\omega_0^1, \omega_1^0), a_{1,0}), ((\omega_0^2, \omega_1^0), a_{2,0}),  ..., ((\omega_0^{N-1}, \omega_1^0), a_{N-1,0}) \\
((\omega_0^0, \omega_1^1), a_{0,1}), ((\omega_0^1, \omega_1^1), a_{1,1}), ((\omega_0^2, \omega_1^1), a_{2,1}),  ..., ((\omega_0^{N-1}, \omega_1^1), a_{N-1,1}) \\
... \\
((\omega_0^0, \omega_1^{M-1}), a_{0,M-1}), ((\omega_0^1, \omega_1^{M-1}), a_{1,M-1}), ((\omega_0^2, \omega_1^{M-1}), a_{2,M-1}),  ..., ((\omega_0^{N-1}, \omega_1^{M-1}), a_{N-1,M-1})
}
$$ -->

Here, $\omega_0$ is the $N$-th root of unity, and $\omega_1$ is the $M$-th root of unity. We assume that both $N$ and $M$ are powers of 2. Given the list of points, we can derive the bivariate Lagrange polynomial:

$$
f(x,y) = \sum\limits_{i=0}^{N-1}\sum\limits_{j=0}^{M-1}a_{i,j}L_i^N(x)L_j^M(y)\\
= \sum\limits_{i=0}^{N-1}\sum\limits_{j=0}^{M-1}a_{i,j}\frac{\prod_{k\neq i}(\omega_0^k-x)}{\prod_{k\neq i}(\omega_0^k-\omega_0^i)}\frac{\prod_{k\neq j}(\omega_1^k-y)}{\prod_{k\neq j}(\omega_1^k-\omega_1^j)}
$$

## Bi-KZG Setup
As we are now dealing with a Lagrange polynomial $f(x,y)$ (with two variables: $x$ and $y$), a different setup is required. Typically, we need to establish the following parameters:

$$
\left(g_1^{L_i^N(\tau_0)L_j^M(\tau_1)}\right)_{i\in [0,N], j\in [0, M]} := \begin{pmatrix}
g _1,& g _1^{L _1^N(\tau _0)},& g _1^{L _2^N(\tau _0^2)},& ...,& g_1^{L _{N-1}^N(\tau _0^{N-1})},\\
g _1^{L _1^M(\tau _1)},& g_1^{L _1^N(\tau_0)L_1^M(\tau_1)},& g_1^{L_2^N(\tau_0^2)L_1^M(\tau_1)},& ...,& g_1^{L _{N-1}^N(\tau_1^{N-1})L_1^M(\tau_1)},\\
\vdots & \vdots & \vdots & \ddots & \vdots\\
g_1^{L _{M-1}^M(\tau_1)},& g_1^{L_1^N(\tau_0)L _{M-1}^M(\tau_1)},& g_1^{L_2^N(\tau_0^2)L _{M-1}^M(\tau_1)},& ...,& g_1^{L _{N-1}^N(\tau_1^{N-1})L _{M-1}^M(\tau_1^{M-1})}
\end{pmatrix}
$$

<!-- 
$$
\displaylines{
(g_1^{L_i^N(\tau_0)L_j^M(\tau_1)})\_{i\in [0,N], j\in [0, M]} = \\
(g_1, g_1^{L_1^N(\tau_0)}, g_1^{L_2^N(\tau_0^2)}, ..., g_1^{L_{N-1}^N(\tau_0^{N-1})},\\
g_1^{L_1^M(\tau_1)}, g_1^{L_1^N(\tau_0)L_1^M(\tau_1)}, g_1^{L_2^N(\tau_0^2)L_1^M(\tau_1)}, ..., g_1^{L_{N-1}^N(\tau_1^{N-1})L_1^M(\tau_1)},\\
...,\\
g_1^{L_{M-1}^M(\tau_1)}, g_1^{L_1^N(\tau_0)L_{M-1}^M(\tau_1)}, g_1^{L_2^N(\tau_0^2)L_{M-1}^M(\tau_1)}, ..., g_1^{L_{N-1}^N(\tau_1^{N-1})L_{M-1}^M(\tau_1^{M-1})})
}
$$ -->
Additionally, we need to establish the public parameters in the cyclic group $\mathbb{G}_2$: $(g_2^{\tau_0}, g_2^{\tau_1})$, which will serve as the verification keys.

## Bi-KZG Commitment
Now, utilizing the updated setup parameters and the Lagrange points, we can calculate the commitment in the following manner:

$$
c = g_1^{f(\tau_0, \tau_1)}
= g_1^{\sum\limits_{i=0}^{N-1}\sum\limits_{j=0}^{M-1}a_{i,j}L_i^N(\tau_0)L_j^M(\tau_1)} 
= \prod_{i=0}^{N-1}\prod_{j=0}^{M-1}\left(g_1^{L_i^N(\tau_0)L_j^M(\tau_1)}\right)^{a_{i,j}}
$$

In this context, $a_{i, j}$ represents the interpolated value, provided during the commitment phase, while $g_1^{L_i^N(\tau_0)L_j^M(\tau_1)} (i \in [0, N], j \in [0, M])$ are generated during the setup phase. It's important to note that the entire commitment algorithm now transforms into a size $NM$ multi-exponentiation operation over $\mathbb{G}_1$.

## Bi-KZG Prove
Suppose a prover is provided with a pair of values $(a, b)$. She returns an evaluation $u$ and asserts that $u$ is equivalent to $f(a, b)$.

To substantiate this claim, the prover must calculate two quotients:

$$
\displaylines{
Q_0(x, b) = \frac{f(x,b) - u}{x-a}\\
Q_1(x,y) = \frac{f(x,y) - u'}{y-b}
}
$$


In this context, $u = f(a,b)$ and $u' = f(x, b)$. Given the evaluations on $\omega_0^i$ ($i \in [0, N]$) and $\omega_1^j$ ($j \in [0, M]$), we can calculate $f(x,b)$ and $f(x,y)$. Additionally, we can compute $Q_0(x,b)$ and $Q_1(x,y)$ using their evaluations on $\omega_0^i$ ($i \in [0, N]$) and $\omega_1^j$ ($j \in [0, M]$).

Subsequently, the prover can calculate the proof in the following manner:

$$
\displaylines{
\pi_0 = g_1^{Q_0(\tau_0, b)}\\
\pi_1 = g_1^{Q_1(\tau_0, \tau_1)}
}
$$

Subsequently, the prover sends the evaluation $u$ and the proof $(\pi_0, \pi_1)$ to the verifier.


## Verifying
Provided with the verification keys $(g_2^{\tau_0}, g_2^{\tau_1})$, the commitment $c = g_1^{f(\tau_0,\tau_1)}$, the evaluation $u = f(a, b)$, and the proofs $\pi_0 = g_1^{Q_0(\tau_0, b)}$ and $\pi_1 = g_1^{Q_1(\tau_0, \tau_1)}$, the verifier can verify the evaluation through the subsequent pairing checks:

$$
\displaylines{
e(\pi_0,g_2^{\tau_0−a} )?=e(g_1^{u'−u},g_2) \\
e(\pi_1,g_2^{\tau_1−b} )?=e(g_1^{c−u'}, g_2)
}
$$

Let us slightly adjust them, so we can compute:

$$
\displaylines{
e(\pi_0, g_2^{\tau_0-a}）\cdot e(\pi_1, g_2^{\tau_1-b}) = e(g_1^{u'-u}\cdot g_1^{c-u'}, g_2)\\
}
$$

To this point, the verifier can locally compute $g_2^a$, $g_2^b$, and $g_1^u$ to verify the above equation. 

Sometimes, it's beneficial to avoid expensive computation in $\mathbb{G}_2$. We can tweak the above equation a little bit as follows:

$$
\displaylines{
e(\pi_0, g_2^{\tau_0})\cdot e(\pi_1, g_2^{\tau_1}) = e(\pi_0^a \cdot \pi_1^b \cdot g_1^{c-u}, g_2)
}
$$

This plausibly replaces two exponents in $\mathbb{G}_2$ with two exponents in $\mathbb{G}_1$, which may improve the gas cost if the verifier is deployed as a smart contract on the blockchain.

# Distributed Computing
The primary advantage of bivariate KZG commitment over univariate is its facilitation of distributed computation. In Proto-Danksharding, we've already observed its utility in data availability sampling. We intend to utilize it for distributed zero-knowledge proof generation in our context. A common example involves using the Message Passing Interface (MPI) to distribute multiple tasks across various machines. Below, we delineate the necessary modifications to each algorithm within the distributed architecture. For the sake of simplicity, let's assume there are $n \leq N$ identical machines involved. Let's further assume $n|N$ and $d = N/n$.

## MPI Setup

Given that we've divided the original task into several sub-tasks, each machine needs to store only a subset of the setup parameters. Assuming we have $n$ machines, machine $k$ only requires the following parameters:

$$
\left(g_1^{L_i^N(\tau_0)L_j^M(\tau_1)}\right)_{i\in [dk,d(k+1)), j\in [0, M]}
$$

## MPI Commitment
Within our architecture, each machine calculates a partial commitment. Subsequently, the root machine gathers these and computes the final commitment. Specifically, the $k$-th machine performs the following computation:

$$
c_k = g_1^{\sum\limits_{i=dk}^{d(k+1) - 1}\sum\limits_{j=0}^{M-1}a_{i,j}L_i^N(\tau_0)L_j^M(\tau_1)} 
= \prod_{i=dk}^{d(k+1) - 1}\prod_{j=0}^{M-1}\left(g_1^{L_i^N(\tau_0)L_j^M(\tau_1)}\right)^{a_{i,j}}
$$

Upon gathering all partial commitments, the root machine calculates the final commitment as $c = \sum\limits_{i=0}^{n-1}c_i$ and transmits it to the verifier.

## MPI Prove
Given that each machine retains a subset of Lagrange points, it first calculates its partial evaluation, denoted by $u_i$. Subsequently, the root machine gathers all partial evaluations and computes $u = \sum\limits_{i=0}^{n-1}u_i$.

In a similar manner, all machines can calculate the partial proofs, $\pi_{0,i}$ and $\pi_1$, based on their Lagrange points. Ultimately, the root machine computes $\pi_0 = \sum\limits_{i=0}^{n-1}\pi_{0,i}$.
